# Изпит, август 2022 г. /версия 2/

## Въпрос 1
<details>
<summary> Кои системни извиквания ползваме за работа с анонимна тръба? Кои системни извиквания работят при файлов дескриптор към файл, но ще завършат с грешка, ако ги ползваме за тръба? </summary>
<br/>

[Въпрос 1, 2022 г.](#q2022_1)
	
</details>

## Въпрос 2
<details>
<summary> Опишете накратко функционалността на системни извиквания sem_post(3), sem_wait(3) и sem_trywait(3). Кои от тези извиквания могат да завършат с грешка EINTR и/или EAGAIN? </summary>
<br/>

[Въпрос 2, 2021 г.](#q2021_2)
	
</details>

# Изпит, януари 2022 г.

## Въпрос 1
<a name="q2022_1">
<details>
<summary> Кои системни извиквания ползваме за работа с анонимна тръба? Кои системни извиквания работят при файлов дескриптор към файл, но ще завършат с грешка, ако ги ползваме за тръба? </summary>
<br/>

``int pipe(int pipefd[2])`` създава анонимна тръба.
	
``ssize_t read(int fd, void *buf, size_t count)`` се използва, за да се чете от тръбата.
	
``ssize_t write(int fd, const void *buf, size_t count)`` се използва, за да се пише в тръбата.
	
``int close(int fd)`` се използва за затваряне на край на тръбата.
	
``pid_t fork(void)`` се използва за създаване на процес, с който да си комуникираме през тръбата.
	
Системните извиквания ftruncate и lseek не работят с файлов дескриптор за тръба.
	
</details>
</а>

## Въпрос 2
<details>
<summary> Опишете накратко функционалността на системни извиквания shm_open(3), ftruncate(2) и mmap(2). </summary>
<br/>
 
[Въпрос 2, 2021г. <Версия 2>](#q2021_22)

</details>

# Контролно, януари 2022 г.
## Въпрос
<details>
<summary> Опишете накратко функционалността на системни извиквания sem_post(3), sem_wait(3) и sem_trywait(3). Кои от тези извиквания могат да завършат с грешка EINTR и/или EAGAIN?</summary>
<br/>
	
[Въпрос 2, 2021 г.](#q2021_2)

</details>

# Контролно, ноември 2021 г.

## Въпрос
<details>
<summary> Какви са приликите и разликите при работа на системните извиквания open(2) и link(2)? Опишете накратко функционалността им.</summary>
<br/>

``int open(const char* pathname, int flags, mode_t mode)`` отваря файл.

В процеса на отваряне се създава указател към текущата позиция във файла (в началото).  Чрез open може да се създаде и нов файл, като тогава mode е кодът на защита на новосъздадения файл. open(2) връща файлов дескриптор към файла или -1 при грешка.

В pathname се подава името на файла (относително или абсолютно), който искаме да се отвори/създаде.

Задава се точно един от флаговете, указващи режим на отваряне - ``O_RDONLY`` (само за четене), ``O_WRONLY`` (само за писане), ``O_RDWR`` (за четене и писане).

Други флагове, които могат да се добавят към флага с режим на отваряне чрез побитово или (|):
  - ``O_APPEND`` - указателят към текущата позиция се премества в края на файла
  - ``O_TRUNC`` - ако вече има такъв файл, неговото съдържание се изтрива
  - ``O_CREAT`` - създава се нов файл, ако такъв не съществува
  
  В при създаване на нов файл, в mode подаваме правата му във вид 0ABC, където A - права на собственика, B - права на групата и C - права на останалите потребители. Можат да се зададат и чрез вградените константи ``S_IRWXU`` (07XX), ``S_IRWXG`` (0X7X) и тн.
	
``int link(const char *oldname, const char *newname)`` създава твърда връзка(**newname**) за съществуващ файл(**oldname**). Твърдата връзка създава ново име на файл, но се свързва към i-node на съществуващия вече файл, като в i-node се увеличава броят на твърдите връзки. link(2) връща 0 при успех и -1 при грешка.

**Прилика:** и с двете се създава ново име на файл

**Разлика:** при link нямаме "реален" нов файл, а твърда връзка към i-node съществуващ файл; open създава файлов дескриптор

</details>

# Изпит, август 2021 г.

## Въпрос 1
<details>
<summary> По какво си приличат системните извиквания open(2), pipe(2) и accept(2)? Опишете накратко функционалността им. </summary>
<br/>

Трите системни извиквания се използват за създаване на някакъв вид "канал" за обмен на данни.
	
``int open(const char* pathname, int flags, mode_t mode)`` отваря файл.

В процеса на отваряне се създава указател към текущата позиция във файла (в началото).  Чрез open може да се създаде и нов файл, като тогава mode е кодът на защита на новосъздадения файл. open(2) връща файлов дескриптор към файла или -1 при грешка.

В pathname се подава името на файла (относително или абсолютно), който искаме да се отвори/създаде.

Задава се точно един от флаговете, указващи режим на отваряне - ``O_RDONLY`` (само за четене), ``O_WRONLY`` (само за писане), ``O_RDWR`` (за четене и писане).

Други флагове, които могат да се добавят към флага с режим на отваряне чрез побитово или (|):
  - ``O_APPEND`` - указателят към текущата позиция се премества в края на файла
  - ``O_TRUNC`` - ако вече има такъв файл, неговото съдържание се изтрива
  - ``O_CREAT`` - създава се нов файл, ако такъв не съществува
  
  В при създаване на нов файл, в mode подаваме правата му във вид 0ABC, където A - права на собственика, B - права на групата и C - права на останалите потребители. Можат да се зададат и чрез вградените константи ``S_IRWXU`` (07XX), ``S_IRWXG`` (0X7X) и тн. 
	
``int pipe(int pipefd[2])`` създава анонимна тръба, която не използва пространството на имената. Тя може да се използва за обмяна на данни между роднински процеси, като записаното в тръбата се буферира в ядрото до прочитане. При успешно създаване на тръба, в подадения като аргумент масив се записват следните файлови дескриптори:
  - ``pipefd[0]`` - файлов дескриптор за четене
  - ``pipefd[1]`` - файлов дескриптор за писане

Системното извикване accept(2) се използва при работа със сокети. Работи се с първата заявка за установяване на логическо съединение от опашката с чакащи заявки. accept(2) приема заявката за изграждане на връзка, като създава нов сокет, с който е установено съединението, и връща неговия файлов дескриптор.
	
</details>

## Въпрос 2
<details>
<summary> Опишете накратко всички начини за създаване на нов процес. </summary>
<br/>

Нов процес се създава чрез системното извикване fork(2).
	
``pid_t fork(void)`` създава процес-дете на текущия, което наследява копие на файловите дескриптори, отворени от родителския процес, текущата директория и потребителския идентификатор на процеса-родител. fork(2) връща 0 в процеса-дете, pid на процеса-дете в процеса-родител и -1 при грешка.
	
</details>

# Изпит, януари 2021 г.

## Въпрос 1
<details>
<summary> Кои системни извиквания работят с файлов дескриптор, създаден с open(2), но ще завършат с грешка за дескриптор, създаден с pipe(2)? Опишете накратко функционалността им. </summary>
<br/>

Системните извиквания ftruncate и lseek не работят с файлов дескриптор, създаден с pipe.

``int ftruncate(int fd, off_t length)`` преоразмерява файл (подаден чрез файловия дескриптор fd) до размер length, като, ако новият размер е повече от стария, след старото съдържание се залепят '\0', а ако новият файл е по-малък, 'излишните' данни се изрязват.
	
``off_t lseek(int fd, off_t offset, int whence)`` премества указателя за текуща позиция на файла с файлов дескриптор fd на offset на брой позиции спрямо отправната точка whence. lseek **не** може да промени размера на файла. Отправната позиция се определя спрямо подадения флаг whence:
  - ``SEEK_SET`` - премества се спрямо началото на файла
  - ``SEEK_CUR`` - премества се спрямо текущата позиция
  - ``SEEK_END`` - премества се спрямо края на файла
	
</details>

## Въпрос 2
<a name="q2021_2">
<details>
<summary> Опишете накратко функционалността на системни извиквания sem_post(3), sem_wait(3) и sem_trywait(3). </summary>
<br/>
  
Трите извиквания се използват за работа със семафори. Това е механизъм за синхронизиране и регулиране на достъпа на много процеси/нишки до ресурс. В даден момент до време до ресурса могат да бъдат допуснати определен брой процеси (инициализирането на този брой се прави при създаването на семафора и се нарича брояч).

Семафорите биват силни или слаби. При силните семафори приспаните процеси се събуждат в реда на приспиване (нареждат се да чакат събуждането си в опашка), а при слабите - не.
	
``int sem_init(sem_t *sem, int pshared, unsigned int value)`` - инициализира неименуван семафор на адрес sem. В pshared се указва дали достъпващите нишки ще са от един процес (0). Ако семафорът е достъпен за повече процеси, то sem трябва да е в споделена памет. Във value се задава началната стойност на брояча.
	
``int sem_post(sem_t *sem)`` увеличава брояча на (отключва) семафорa sem. Aко броячът на sem стане повече от 0, се събужда друг процес, заключен в sem_wait(3), който заключва семафора.
	
``int sem_wait(sem_t *sem)`` намалява брояча на (заключва) семафора sem. Ако броячът на sem е 0, процесът блокира докато декрементирането не стане възможно. sem_wait(3) връща грешка EINTR ако извикването е било прекъснато от сигнал.
	
``int sem_trywait(sem_t *sem)`` е подобно на sem_wait(3), но не блокира, а връща грешка EAGAIN ако семафорът не може да се декрементира веднага (т.е. имал е стойност 0 и е бил заключен). Може да върне EINTR аналогично на sem_wait(2).

</details>
</a>

# Изпит, януари 2021 г. /версия 2/
## Въпрос 1
<details>
<summary> Какви са приликите и разликите при работа на системните извиквания close(2) и unlink(2)? Опишете накратко функционалността им.</summary>
<br/>

``int close(int fd)`` затваря файловия дескриптор, подаден като параметър. Освобождава се файловия дескриптор и вече неговият номер може да бъде използван за други файлове. Ако този файлов дескриптор е бил на изтрит файл, то файлът се унищожава окончателно.
	
``int unlink(const char* pathname)`` изтрива име от файл от файловата система и намаля броя на твърдите връзки, като, ако към i-node на файла няма други твърди връзки, то паметта се освобождава. Ако файлът е бил мека връзка, то тя се изтрива, но не това не указва ефект върху файла, към който е била свързана. Ако pathname е сочел към сокет или именувана тръба, то тя не се изтрива до затварянето на всички файлови дескриптори към нея.

**Прилика:** и при двете ако има процеси, които работят с файла, то той не се изтрива до приключване на работата

**Разлика:** close(2) затваря файлови дескриптори, а unlink(2) - имена от файловата система

</details>

## Въпрос 2
<a name="q2021_22">
<details>
<summary> Опишете накратко функционалността на системни извиквания shm_open(3), ftruncate(2) и mmap(2). </summary>
<br/>
  
Трите извиквания се използват за работа със споделена памет.

``int shm_open(const char *name, int oflag, mode_t mode)`` създава или отваря обект от тип POSIX споделена памет, който позволява на нероднински процеси да използват една и съща област памет. Извикването връща fd към паметта, като ако паметта се създава тепърва, връща обект - споделена памет, с размер 0 байта, който трябва да се преоразмери с ftruncate(2).

``int ftruncate(int fd, off_t length)`` преоразмерява файл (подаден чрез файловия дескриптор fd) до размер length, като, ако новият размер е повече от стария, след старото съдържание се залепят '\0', а ако новият файл е по-малък, 'излишните' данни се изрязват.
	
``void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)`` създава нов mapping във виртуалното адресно пространство на извикващия процес от адреса addr с дължина length и го инициализира със съдържанието на файла с файлов дескриптор fd. Файлът след това може да бъде достъпен като масив и да се избегне работа за системните извиквания за работа с файлове.

</details>
</a>
