# Системно програмиране

### Операционна система
Занимава се с:
- управление на правата за достъп
- управление на процесите
- обмяна на информация между процесите

### POSIX слой
Представлява **междинен слой**, към който се отправят извикванията към ядрото

### Driver
 - заменя конкретна програма за управление на хардуера с по-абстрактна концепция
 - предоставя **абстракция** - заменя _група устройства_ с едно, управлявано с библиотечни функции

### Файл
Състои се от:
- име
- стойност (значение)
- права за достъп

### Файлова система
Представлява **изображение** от типа: <име на файл> → <масив от байтове>

### Файлов дескриптор
Предоставя **локален указател** към обект/споделена структура в ядрото

### Стъпки за работа с файл
1. създаване на файлов дескриптор 
	- ``open(<...>)`` - за файл
	- ``socket()`` - за сокет
	- ``pipe()`` - за неименувана тръба
2. работа с файлов дескриптор
	- ``read(<...>)`` - четене
	- ``write(<...>)`` - писане
	- ``lseek(<...>)`` - преместване на позицията във файла
	- ``ftruncate(<...>)`` - преоразмеряване на файла
3. затваряне
	- ``close(<...>)`` - затваряне на файлов дескриптор

### Отваряне на файл

- ``int open(const char* pathname, int flags, mode_t mode)``
	- при отваряне адресацията става спрямо **главната директория**
	- в процеса на отваряне се създава указател към **текущата позиция** във файла
	- задава се точно един от флаговете ``O_RDONLY``(само за четене), ``O_WRONLY``(само за писане), ``O_RDWR``(за четене и писане)
	- други флагове:
		- ``O_APPEND`` - указателят към текущата позиция се премества в края на файла
		- ``O_TRUNC`` - ако вече има такъв файл, той се изтрива
		- ``O_CREAT`` - създава се нов файл, ако такъв не съществува
	
- ``int creat(const char *pathname, mode_t mode)``
	- използваме го като алтернатива на ``open(<...>, O_CREAT|O_WRONLY|O_TRUNC, <...>)``

- грешки:
	- ``EACCESS`` - нямаме достатъчни права за достъп
	- ``EISDIR`` - обектът е директория
	- ``ENOMEM`` - няма достатъчно памет

### Затваряне на файл

- ``int close(<int fd>)``
	- затваря се подаденият като аргумент файлов дескриптор

### Четене и писане

- ``ssize_t read(int fd, void *buf, size_t count)``
	- прочитат се до count на брой байта от файловия дескриптор fd, записват се в буфера buf и се връща броят реално прочетени байтове
	- ако файлът е бил **успешно прочетен** завършва без грешка и с 0 прочетени байта

- ``ssize_t write(int fd, const void *buf, size_t count)``
	- пишат се до count на брой байта от буфера buf във файловия дескриптор fd и се връща броят реално записани байтове

### Работа с указател към текуща позиция

- ``off_t lseek(int fd, off_t offset, int flag)``
	- премества се указателят за текуща позиция на offset на брой позиции спрямо отправната точка
	- отправната позиция се определя спрямо подадения флаг:
		- ``SEEK_SET`` - премества се спрямо началото на файла
		- ``SEEK_CUR`` - премества се спрямо текущата позиция
		- ``SEEK_END`` - премества се спрямо края на файла

**``lseek`` не може да промени размера на файл!**


### Тръби

- ``int pipe(int pipefd[2])``
	- създава се **анонимна** тръба, която не използва пространството на имената
	- може да се използва за обмяна на данни между **роднински** процеси
	- при успешно създаване на тръба в подадения като аргумент масив се записват следните файлови дескриптори:
		- ``pipefd[0]`` - файлов дескриптор за **четене**
		- ``pipefd[1]`` - файлов дескриптор за **писане**
	- данните, записани в тръбата, се **буферират** в ядрото до прочитане
	- ако няма отворен файлов дескриптор за писане, при четене от тръбата ще получим EOF
	- ако буферът на тръбата се напълни при писане, ``write`` ще блокира или ще даде грешка (при вдигнат флаг ``O_NONBLOCK``)


- ``int mkfifo(const char *pathname, mode_t mode)``
	- създава се **именувана тръба** - специален вид файл, на указания като параметър адрес
	- отваря се с ``open`` със съответните флагове
	- за да може да се работи с нея, трябва да бъде отворена **едновременно** от края за четене и от края за писане, иначе блокира

### Мета информация

- ``int stat(const char* pathname, struct* stat)``
	- връща мета информация за файла

- ``int lstat(const char *path, struct stat *buf)``
	- ако името е символна връзка, то се връща информация за **връзката**, а не за файла, който тя сочи

### Права за достъп

- ``int chmod(const char* pathname, mode_t mode)`` 
	- сменят се правата за достъп на файла
- ``int chown(const char* filename, uid_t owner, gid_t group)``
	- променят се собственика и групата на файла (задава се един от аргументите owner или group да е -1, и се извършва промяна върху **другия**)
	- тази операция е успешна само ако се извършва от **root** потребителя или от **собственика** на файла
- ``mode_t umask(mode_t mask)`` 
	- променя се маската на правата на достъп при създаване на файлове за **текущия процес**
	- връща се старата стойност на маската
- ``int utime(const char *filename, const struct utimbuf *times)``
	- променят се времената на последен достъп и последна промяна на i-node, посочен от filename, със съответните стойности в структурата times (ако не е подадена се задават на текущото системно време)
	- връща 0 при успех и -1 при неуспех

### Работа с файлови дескриптори

- ``int fcntl(int fildes, int cmd, ...)``
	- използва се за **манипулация** на файлови дескриптори (смяна и преглед на флагове, дублиране на дескриптор и т.н.)

- ``int dup(int fd)``
	- файловият дескриптор fd се копира на **първото свободно място** в  таблицата на файловите дескриптори

- ``int dup2(int fd, int new_fd)``
	- затваря се newfd, ако е отворен, и fd се копира на негово място
	- ако ``fd == new_fd``, **нищо** не се случва (няма затваряне или копиране)

**Файловите дескриптори, направени чрез dup, имат общи:**
- един и същи отворен файл
- **oбщ** указател към текуща позиция (т.е. ако от единия fd указателят се премести, другият работи с преместения указател)
- еднакъв режим на отваряне на файла

### Твърди и символни връзки

- индексен описател (**i-node**)
	- в него се съхраняват:
		- всички **атрибути** на файла
		- брой на **твърдите** връзки
		- **адресната информация** за разположението на файла на диска
	- има фиксирана дължина

- твърди връзки (**hard link**)
	- свързват се към i-node на **съществуващ файл**
	- промяната на стария файл е същата като промяната на новия, защото те **споделят** един и същи i-node

- символни връзки (**symbolic link**)
	- създава се **отделен i-node**
	- ако се изтрие файлът, към който сочи символната връзка, тя се "чупи"

- ``int link(const char *oldname, const char *newname)``
	- създава твърда връзка за **съществуващ** файл
	- създава **ново име** на файл, но се свързва към **i-node на съществуващия**
	- в i-node се **увеличава броят на твърдите връзки**

- ``int unlink(const char* filename)``
	- премахва **името на файла** от директорията
	- **намаля броя на твърдите връзки** в i-node с 1, като ако те станат 0, паметта се освобождава

- ``int symlink(const chat* toname, const char* fromname)``
	- създава се **символна връзка** с име fromname, сочеща към toname
	- съществуването на toname **не** се гарантира

### Каталог (директория)

- **Представяне на директориите**

	- **DIR** - тип структура, която се свързва с отворена за четене директория и се **използва от останалите функции**

	- **dirent** - тип структура, която съдържа номер на i-node и име на файл

- ``int mkdir(const char *dirname, mode_t mode)``
	- създава **нов празен** (съдържащ само . и ..) каталог с указаното име и права на достъп mode
	- създаващият процес трябва да има **права за писане** за родителския каталог на новосъздадения и права за изпълнение за всички каталози по пътя от началната директория

- ``int rmdir(const char *dirname)``
	- унищожава каталога с подаденото име
	- за да е успешно, трябва каталогът да е **празен**

- ``int chdir(const char* dirname)``
	- променя текущия каталог на процеса по подадено като параметър **име на директория**

- ``int fchdir(int fd)`` 
	- променя текущия каталог на процеса по подаден като параметър **файлов дескриптор** - идентификатор на каталога

- ``DIR* opendir(const char* dirname)`` 
	- отваря **за четене** каталог 
	- връща **указател към DIR** - идентификатор на отворения каталог

- ``struct dirent *readdir(DIR* dir)`` 
	- чете поредния **следващ запис** от директорията (при първо извикване - първия запис)
	- връща файла като обект от тип **dirent**

- ``void rewinddir(DIR *dir)``
	- позиционира текущата позиция в началото на директорията

- ``int closedir(DIR *dir)``
	- затваря каталога и освобождава dir


### Процеси

- ``pid_t fork(void)``
	- създава процес-дете на текущия, което наследява:
		- **копие на файловите дескриптори**, отворени от родителския процес
		- текущ каталог
		- потребителски идентификатор
	- връща:
		- ``0`` - в процеса-дете 
		- ``<pid на процеса-дете>`` - в процеса-родител
		- ``-1`` - при грешка

- ``pid_t getpid``
	- връща id на процеса на извикващия процес
- ``pid_t getppid``
	- връща id на процеса-родител на извикващия процес

- ``pid_t wait(int *status)``
	- **блокира** текущия процес до приключване на първия процес-дете
	- връщат pid на приключилия процес-дете
	- записва **кода на завършване** в status

- ``pid_t waitpid(oid_t pid, int *status, int options)`` 
	- блокира текущия процес до приключване на процеса-дете с **указан pid**

**Всеки завършил процес остава в системата в състояние зомби докато родителският процес не изпълни wait!**

- ``void exit(int status)``
	- осигурява чисто завършване на процеса
	- затваря незатворените потоци

- ``int atexit(void (*function) (void))``
	- указва функции, които да се извършат преди приключване на програмата

- ``exec``
	- текущата програма извиква за изпълнение друга, като новата програма **наследява файловите дескриптори** на извикващия процес

### Сигнали

- сигнал 
	- механизъм за **междупроцесна комуникация**
	- информират за **асинхронни** събития
	- събитията се обработват по един от 3 начина:
		- процесът **завършва**
		- сигналът се **игнорира**
		- процесът **изпълнява действие** и се връща там, откъдето е бил прекъснат

- ``int kill(pid_t pid, int sig)``
	- изпраща сигнал от един процес към друг(и)
 
- ``int pause(void)``
	- блокира процеса до получаване на първия сигнал, **който не се игнорира**
	- връща ``-1``

- ``unsigned alarm(unsigned sec)`` 
	- **планира** изпращането на сигнал ``SIGALARM`` на **текущия процес** след sec секунди

- ``void (*signal(int sig, void (*sighandler) (int)))(int)``
	- определя **реакцията** sighandler на процеса при получаване на сигнала с номер sig
	- реакциите могат да бъдат:
		- ``SIG_IGN`` - сигналът се **игнорира**
		- ``SIG_DFL`` - съобщава на ядрото да предприеме **стандартната реакция** за получения тип сигнал
		- ``<име на потребителска функция>`` - изпълнява се функцията

**При обработката на сигнали могат да възникнат следните проблеми:**

- може да се получи **състезание** на сигнали от един и същи тип
- може да има **загуба** на сигнали, защото в даден момент ядрото има памет само за по 1 сигнал от тип
	
	
### Сокет

- сокет (socket)
	- представлява **единия край** на комуникационен канал

- действие на **сървъра**:
	- ``socket()`` - създава сокет
	- ``bind()`` - присвоява име на сокета
	- ``listen()`` - започва приемане на заявки за връзки
	- ``accept()`` - приема заявка за изграждане на връзка, създава нов сокет и връща неговия fd

- действие на **клиента**:
	- ``socket()`` - създава сокет
	- ``connect()`` - подава заявка за изграждане на връзка, връща fd на клиента


### Споделена памет

- ``int shm_open(const char *name, int oflag, mode_t mode)``
	- **създава или отваря** обект от тип POSIX  споделена памет, който позволява на **нероднински** процеси да използват една и съща област споделена памет
	- връща fd към паметта
    - ако паметта се създава тепърва, връща обект - споделена памет, с размер **0 байта**, който трябва да се преоразмери с ``ftruncate()``

- ``smh_unlink(const char *name)``
	- **премахва** обект от тип POSIX споделена памет

- ``void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)``
	- създава **нов mapping** във виртуалното адресно пространство на извикващия процес от адреса addr с дължина length
	- **инициализира** се със съдържанието на файла с файлов дескриптор fd


> [📑](https://linuxhint.com/using_mmap_function_linux/) The ``mmap()`` function is used for mapping between a process address space and either files or devices. When a file is mapped to a process address space, the file can be **accessed like an array** in the program. This is one of the most efficient ways to access data in the file and  provides a **seamless coding interface** that is natural for a data structure that can be assessed without he abstraction of reading and writing from files. 

### Семафори

- семафори
	- позволяват **синхронизираната** работа на процеси и нишки
	- представляват **неотрицателни цели числа**, които могат да се увеличават и намаляват
	- при 0 семафорът е **блокиран**

- ``int sem_init(sem_t *sem, int pshared, unsigned int value)``
	- инициализира **неименуван семафор** на адреса sem с начална стойност value

- ``int sem_post(sem_t *sem)``
	- **увеличава** брояча на (отключва) семафорa sem
	- ако броячът стане повече от 0 и имаме блокиран в sem_wait(2) процес, той се събужда и заключва семафора

- ``int sem_wait(sem_t *sem)``
	- **намалява** брояча на (заключва) семафора sem
	- ако броячът е 0, процесът блокира докато декрементирането не стане възможно
    - връща **EINTR** ако извикването е било прекъснато от сигнал

- ``int sem_trywait(sem_t *sem)``
	- **намалява** брояча на (заключва) семафора sem
	- работи само ако в момента **не е** заключен
	- връща **EINTR** ако извикването е било прекъснато от сигнал
	- връща **EAGAIN** ако семафорът не може да се заключи веднага (т.е. вече е бил заключен)

- ``int sem_destroy(sem_t *sem)``
	- унищожава семафора sem

### Съобщения

- съобщения
	- POSIX позволява на процесите да **обменят информация** чрез съобщения
	- съобщенията се запазват в **приоритетна опашка**

- ``mqd_t mq_open(const char *name, int oflag)``
	- създава **нова опашка** от съобщения и връща нейния дескриптор, или отваря съществуваща
	- могат да се подадат следните флагове:
		- ``O_RDONLY`` - отваря опашката само за четене
		- ``O_WRONLY`` - отваря опашката само за писане
		- ``O_RDWR`` - отваря опашката за четене и писане

- ``int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio)`` 
	- **добавя съобщението** msg_ptr към опашката от съобщения mqdes
	- ако опашката е пълна **блокира** до освобождаване
	- съобщенията се нареждат по **приоритет**

- ``ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio)``
	- **премахва поредното съобщение** от опашката mqdes, записва го в буфера msg_ptr и записва в msg_prio приоритета на съобщението
	- ако опашката е празна, **блокира** до получаване на съобщение 